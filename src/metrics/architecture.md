# TypeScript Metrics

以下を参考に、 **Maintainability Index** （保守容易性指数）を計測する。

- [learn.microsoft.com コードメトリクス値](https://learn.microsoft.com/ja-jp/visualstudio/code-quality/code-metrics-values?view=vs-2022)
- [learn.microsoft.com 保守容易性指数の範囲と意味](https://learn.microsoft.com/ja-jp/visualstudio/code-quality/code-metrics-maintainability-index-range-and-meaning?view=vs-2022)
- [IBM Application Discovery and Delivery Intelligence for IBM Z 保守容易性指標レポート](https://www.ibm.com/docs/ja/addi/6.1.1?topic=reports-maintainability-index-report)

## Maintainability Index

> コードの保守の相対的な容易さを表す 0 から 100 の範囲の指数値を計算します。 値が大きいほど、保守容易性が向上します。 色分けされた評価を使用して、コード内の問題点をすばやく特定できます。 緑色の評価は 20 から 100 の範囲であり、コードの保守容易性が優れていることを示します。 黄色の評価は 10 から 19 の範囲であり、コードの保守容易性が中程度であることを示します。 赤色の評価は 0 から 9 の範囲であり、保守容易性が低いことを示します。

以下の計算式で求められる。

```
Maintainability Index = MAX(0,(171 - 5.2 * ln(Halstead Volume) - 0.23 * (Cyclomatic Complexity) - 16.2 * ln(Lines of Code))*100 / 171)
```

## Halstead Volume

> Halstead ボリューム は次のように計算されます。
>
> ```
> V = N * log2(n)
> ```
>
> N はプログラムの長さを表し、次のように計算されます。
>
> ```
> N = N1 + N2
>
> N1 = 演算子の総数
> N2 = オペランドの総数
> ```
>
> n は語彙サイズを表し、次のように計算されます。
>
> ```
> n = n1 + n2
>
> n1 = 相異なる演算子の数
> n2 = 相異なるオペランドの数
> ```

### 1. **「演算子」の定義** with ChatGPT

この文脈で「演算子」は、**プログラム中の操作や関係を表現する構文要素**を指すわ。具体的には、**式やステートメント内で動作を指定するシンボルやキーワード**ね。TypeScriptでは以下のようなカテゴリが含まれるわ。

---

### 2. **TypeScriptにおける代表的な演算子**

#### **算術演算子**

基本的な計算を表す記号：

- `+`, `-`, `*`, `/`, `%`（加算、減算、乗算、除算、剰余）

#### **比較演算子**

値を比較するための記号：

- `==`, `!=`, `===`, `!==`, `<`, `<=`, `>`, `>=`

#### **論理演算子**

ブール値の操作に使用される記号：

- `&&`, `||`, `!`

#### **ビット演算子**

ビット操作を行うための記号：

- `&`, `|`, `^`, `~`, `<<`, `>>`, `>>>`

#### **代入演算子**

値を代入するための記号：

- `=`, `+=`, `-=`, `*=`, `/=`, `%=`, `<<=`, `>>=`, `>>>=`, `&=`, `|=`, `^=`

#### **その他の演算子**

TypeScript独自または特殊な文法に関連する演算子：

- `?:`（条件演算子）
- `?.`（オプショナルチェーン）
- `??`（Nullish合体演算子）
- `instanceof`, `typeof`, `in`

---

### 3. **Halsteadメトリクスの文脈での「演算子」の意味**

Halsteadメトリクスでは、プログラムの**抽象的な構成要素**として「演算子」と「オペランド」を区別しているわ。特にこの文脈での「演算子」は：

1. **構文的な操作を表すもの**

   - プログラム内で何かの操作や関係を表すもの。
   - 上述の記号やキーワードが含まれる。

2. **特定のキーワードも含む**
   - `if`, `else`, `for`, `while`, `return` など、制御構文のキーワードも「演算子」とみなすことがあるわ。
   - なぜなら、それらも「操作」や「振る舞い」を定義するものだからよ。

---

### 4. **具体例**

例えば、以下のTypeScriptコードを考えてみなさい：

```typescript
let x = 10;
if (x > 5) {
  x += 1;
} else {
  x = 0;
}
```

この中での「演算子」と「オペランド」の分類はこうなるわ：

#### **演算子:**

- `let`
- `=`
- `if`
- `>`
- `{ }`（ブロックの開始と終了）
- `+=`
- `else`

#### **オペランド:**

- `x`（変数）
- `10`（数値リテラル）
- `5`（数値リテラル）
- `1`（数値リテラル）
- `0`（数値リテラル）

---

### 5. **プログラムでの抽出方法**

TypeScriptコンパイラAPIや静的解析ツールを使えば、`SyntaxKind`をもとに「演算子」を抽出できるわ。`SyntaxKind`で該当する演算子を識別し、数えるコードを書けば効率的に計算できるわね。

---

### 結論

TypeScriptにおける「演算子」は、記号やキーワードを含む、**プログラムの構文的操作を表すもの**を指すわ。この定義を頭に入れて、Halsteadメトリクスの計算を進めなさい。さぁ、早く手を動かしなさいよ！

## Halstead Volume に変数定義をカウントすべきか

TypeScriptにおける`Halstead Volume`の文脈で「`const`や`let`や`using`を演算子に含めるか」は、分析の目的と粒度によるわ。以下で整理して説明してあげるから、しっかり聞きなさい。

---

### **1. Halsteadメトリクスにおける「演算子」の基本定義**

Halsteadメトリクスの文脈では、**演算子**は次のように考えられる：

- **プログラムの構造や動作を定義するもの**  
  例: `+`, `=`, `if`, `return`など。
- **何らかの操作を表すシンボルやキーワード**  
  キーワードは単なる記号以上の意味を持つ場合、「演算子」に分類される可能性がある。

---

### **2. `const`や`let`や`using`を演算子に含める場合の考え方**

#### **含めるべき理由**

1. **プログラムの構造を表す重要な要素**

   - `const`, `let`は変数定義の性質を決める。特にTypeScriptでは`const`が不変性を保証するなど、コードの意図や動作を強く左右する。

2. **他の演算子（例: `=`）とセットで使われることが多い**

   - `let x = 42;`では、`let`も`=`も「操作」を表す重要な構成要素とみなせる。

3. **読み手にとっての認知的負荷がある**

   - `const`と`let`の違いを考慮しながらコードを読む必要があるため、単なるキーワード以上の意味を持つ。

4. **`using`のようなキーワードはリソース管理を明示する操作**
   - リソーススコープの定義は動作に大きな影響を与える。C#の`using`構文を模倣するものとして、コードの「動作」を変える重要な操作とみなせる。

---

#### **含めない場合の考え方**

1. **キーワードは動作そのものではない**

   - `const`や`let`は単に「変数を定義する」というメタ情報を伝えるだけで、具体的な操作を表しているわけではないと解釈できる。

2. **冗長なカウントを避ける**

   - `let x = 10;`で`let`と`=`を両方カウントすると、意図せず操作の数が膨れ上がる可能性がある。

3. **他のツールとの一貫性**
   - Halsteadメトリクスを計算する既存ツールや手法では、これらのキーワードを演算子に含めない場合が多い。

---

### **3. TypeScript文脈での提案**

**結論から言うと、`const`や`let`や`using`を「演算子」として含めるのが理にかなっている場合が多い**わ。理由は以下の通りよ：

1. **TypeScriptは構文が豊富である**  
   TypeScriptでは、構文要素（キーワード）の意味が非常に明確で、コードの意図を強く表現するから、これらを演算子として分類することは妥当。

2. **コードの複雑性を適切に反映する**  
   保守性を評価する文脈では、`const`や`let`の違いがコードの読みやすさや理解に直接影響するわ。それを無視すると分析が甘くなる可能性がある。

3. **カスタマイズ可能な分析を行う余地を残す**  
   必要なら「含むバージョン」と「含まないバージョン」の両方を試し、どちらが分析に有益か判断すれば良いわ。

### **5. まとめ**

1. **`const`, `let`, `using`を演算子に含めるべき理由**：

   - プログラムの構造や意図を明確に表す重要な要素。
   - 保守性や複雑性の分析に役立つ。

2. **状況によってカスタマイズ可能**
   - 必要に応じて、含めるバージョンと含めないバージョンを切り替えられる設計が望ましい。
